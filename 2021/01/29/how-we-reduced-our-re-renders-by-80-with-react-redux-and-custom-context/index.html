<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Tjerk Woudsma | Blog"><meta name="author" content="Tjerk Woudsma"><meta property="og:title" content="How we reduced our re-renders by 80% with React Redux and custom context"><meta property="og:description" content="Tjerk Woudsma | Blog"><meta property="og:site_name" content="console.blog"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.tjerkwoudsma.com/img/header-image.jpg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog.tjerkwoudsma.com/img/header-image.jpg"><title>How we reduced our re-renders by 80% with React Redux and custom context - console.blog</title><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"><link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet"><link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet"><!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.3.0"></head><body><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" target="_blank" rel="noopener" href="https://tjerkwoudsma.com">tjerkwoudsma.com</a></div><div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a target="_blank" rel="noopener" href="https://github.com/woudsma"><i class="fa fa-github"></i></a></li></ul></div></div></nav><header class="intro-header" style="background-image:url(/img/header-image.jpg)"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><h1>How we reduced our re-renders by 80% with React Redux and custom context</h1><span class="meta">2021-01-29</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the project I’m currently working on for a client, my collegues and I started to notice performance degradation in our React app, which mostly consists of complex forms and different kinds of input components. Things started to get so bad after a while that basic input fields couldn’t keep up with fast typing. This was annoying at first, but soon required action.</p><p>This might seem obvious, but if you notice that <strong>your</strong> machine is struggling with the app you’re building, it’s safe to assume that the experience for users on lower-end devices is going to be horrible. This especially becomes a problem when you’re working on a multi-language, globally used web app for example. As developers we’re usually working on fast Macbook Pro’s (or other up-to-date hardware), I’m using a 6-Core Intel Core i7 with 16GB of RAM for reference. It’s good to keep in mind, because performance in React apps doesn’t seem to be a problem that much these days.</p><p>When we starting looking into the cause of these performance issues, we found that most React components in the form would re-render whenever any form input value changed. We knew that this was caused by poor (un-optimized) handling of user events and data flow. Some of our components were hundreds of lines of JavaScript long - a red flag on it’s own - and had dozens of props that were being passed down multiple levels deep. This can impact performance as well, and debugging such components is no fun either. This is also often referred to as ‘prop-drilling’.</p><p>Digging a little deeper, we looked into our JavaScript performance using Chrome’s JS Profiler. Here we noticed that some frames would take up to 250-1000ms to render, when ideally you’d want that to be under 16.6ms for your browser to be able to render the app at 60fps.</p><p>When we measured how many times our <code>Input</code> component would render during a normal user interaction flow, we saw that in some cases the component would re-render up to <strong>800-1300 times</strong>! Whoops!</p><p>We were using <a target="_blank" rel="noopener" href="https://reactjs.org/docs/context.html">React Context</a> for a lot of things - for retrieving values, accessing setter / getter functions and to keep track of the entire form state. While I do love the introduction of React Context and it’s ease of use, I suspected that - out of the box - things weren’t as optimized as one might assume. This started to become a problem as our app grew in complexity.</p><p>I’ve worked with <a target="_blank" rel="noopener" href="https://redux.js.org/">Redux</a> and <a target="_blank" rel="noopener" href="https://react-redux.js.org/">React Redux</a> a lot in previous projects, and I know that while it <em>does</em> add some boilerplate and a few kb’s to your bundle, it’s very reliable and has matured nicely over the years 👌. Smart people have worked long and hard to optimize it’s performance so I feel comfortable using it in mission-critical situations.</p><p>Let’s dive into the approach we took to optimize the performance of our React application!</p><h3 id="Performance-optimizations-todo’s"><a href="#Performance-optimizations-todo’s" class="headerlink" title="Performance optimizations todo’s"></a>Performance optimizations todo’s</h3><p>Before we started, we made a summary of things that we knew would improve overall performance. Not all of these improvements (such as using <code>React.memo</code>) are covered in this post, but I’ve tried to cover the most important parts.</p><ol><li>Move business logic to container components and render presentational components</li><li>Use <code>React.useCallback</code> for functions that are passed down to children</li><li>Use <code>React.memo</code> for components that receive many props but don’t need to re-render</li><li>Use <code>React.useMemo</code> to cache computationally heavy functions</li><li>Move a lot of re-used business logic to hooks</li><li>Use <a target="_blank" rel="noopener" href="https://github.com/reduxjs/reselect"><code>reselect</code></a> to memoize and compose redux selectors</li><li>Use a custom context with redux store instead of react context</li><li>Prevent re-renders by avoiding prop-drilling</li></ol><h3 id="Your-app-currently-looks-something-like-this"><a href="#Your-app-currently-looks-something-like-this" class="headerlink" title="Your app currently looks something like this"></a>Your app currently looks something like this</h3><p>You’ve got a React app with an existing global store (this is optional). I’ve included a global Redux store just to illustrate that we can use multiple stores next to each other. There’s a good chance that your company or client uses Redux already anyway.</p><p>Here we’ll focus mainly on the components rendered inside <code>&lt;App /&gt;</code>, I don’t really care about the rest of the app, this might have been written by someone else, so preferably I don’t even need to touch it.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><br><span class="hljs-keyword">import</span> &#123; render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span><br><span class="hljs-keyword">import</span> &#123; Provider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span><br><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./globalStore&quot;</span><br><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App&quot;</span><br><br>render(<br>  &lt;Provider store=&#123;store&#125;&gt;<br>    &lt;App /&gt;<br>  &lt;/Provider&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>),<br>)<br></code></pre></td></tr></table></figure><h3 id="With-a-‘global’-Redux-store-already-in-place"><a href="#With-a-‘global’-Redux-store-already-in-place" class="headerlink" title="With a ‘global’ Redux store already in place"></a>With a ‘global’ Redux store already in place</h3><p>Quick example of a store that might exist inside your app already.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Define and export action types.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> INIT_APP = <span class="hljs-string">&quot;INIT_APP&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SOME_GLOBAL_FORM_ACTION = <span class="hljs-string">&quot;SOME_GLOBAL_FORM_ACTION&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SOME_GLOBAL_RESET_FORM_ACTION = <span class="hljs-string">&quot;SOME_GLOBAL_RESET_FORM_ACTION&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Example &#x27;global&#x27; redux store</span><br><span class="hljs-comment"> * that might exist in your app already.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  initialized: <span class="hljs-literal">false</span>,<br>  forms: &#123;&#125;,<br>  someUserData: &#123;&#125;,<br>  <span class="hljs-comment">// ... etc</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A standard reducer function.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">state</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">action</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">nextState</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, &#123; type, payload &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> INIT_APP:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        initialized: <span class="hljs-literal">true</span>,<br>      &#125;<br>    <span class="hljs-keyword">case</span> SOME_GLOBAL_FORM_ACTION:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        forms: &#123; ...state.forms, [payload.formId]: payload.values &#125;,<br>      &#125;<br>    <span class="hljs-keyword">case</span> SOME_GLOBAL_RESET_FORM_ACTION:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        forms: &#123;<br>          ...state.forms,<br>          [payload.formId]: initialState.forms?.[formId],<br>        &#125;,<br>      &#125;<br>    <span class="hljs-comment">// ... etc</span><br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createStore(reducer)<br></code></pre></td></tr></table></figure><h3 id="But-now-we’ve-got-several-instances-of-large-complex-components-in-our-app"><a href="#But-now-we’ve-got-several-instances-of-large-complex-components-in-our-app" class="headerlink" title="But now we’ve got several instances of large / complex components in our app"></a>But now we’ve got several instances of large / complex components in our app</h3><p>In case of the project I’m working on we’re dealing with ‘dynamic’ forms which can be configured in our CMS. These forms contain a lot of logic (too much IMHO), but these are real-world scenarios we must deal with in larger codebases.</p><p>Here you can see that we render the <code>App</code> component with some children, and when the app renders for the first time it dispatches an example action <code>INIT_APP</code> to the ‘global’ redux store. This is just to illustrate what your current app might look like.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><br><span class="hljs-keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span><br><br><span class="hljs-keyword">import</span> &#123; FormContainer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./FormContainer&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * App component with some example form components.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;React.FC&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> dispatch = useDispatch()<br>  <span class="hljs-keyword">const</span> isInitialized = useSelector(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.initialized)<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isInitialized) dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;INIT_APP&quot;</span> &#125;)<br>  &#125;, [dispatch, isInitialized])<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &lt;h1&gt;React + Redux app&lt;/h1&gt;<br>      &lt;hr /&gt;<br>      &lt;FormContainer formId=<span class="hljs-string">&quot;homeBillingForm&quot;</span> /&gt;<br>      &lt;FormContainer formId=<span class="hljs-string">&quot;homeShippingForm&quot;</span> /&gt;<br>      &lt;FormContainer formId=<span class="hljs-string">&quot;guestLoginForm&quot;</span> /&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h3 id="Let’s-seperate-logic-with-container-and-presentational-components"><a href="#Let’s-seperate-logic-with-container-and-presentational-components" class="headerlink" title="Let’s seperate logic with container and presentational components"></a>Let’s seperate logic with container and presentational components</h3><p>Presentational components can be tested with ease. Simply mock the required props and you’re good to go.</p><p>You should be able to write these components without the <code>return</code> keyword, as in the following examples. I try to do no logic <em>at all</em> inside presentational components.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Form presentational component.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;React.FC&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> Form = <span class="hljs-function">(<span class="hljs-params">&#123; children, ...props &#125;</span>) =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> &#123;<span class="hljs-attr">...props</span>&#125;&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Form<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Example input presentational component.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;React.FC&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> FormInput = <span class="hljs-function">(<span class="hljs-params">&#123; children, ...props &#125;</span>) =&gt;</span> (<br>  &lt;div className=<span class="hljs-string">&quot;FormInput&quot;</span>&gt;<br>    &lt;input type=<span class="hljs-string">&quot;text&quot;</span> &#123;...props&#125; /&gt;<br>    &#123;children&#125;<br>  &lt;/div&gt;<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> FormInput<br></code></pre></td></tr></table></figure><h3 id="And-we’ll-use-a-React-Context"><a href="#And-we’ll-use-a-React-Context" class="headerlink" title="And we’ll use a React Context"></a>And we’ll use a <a target="_blank" rel="noopener" href="https://reactjs.org/docs/context.html">React Context</a></h3><p>Simply create an empty context, we will use this later on.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><br><br><span class="hljs-keyword">const</span> FormContext = createContext(<span class="hljs-literal">null</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> FormContext<br></code></pre></td></tr></table></figure><h3 id="Now-we’ll-create-the-container-components"><a href="#Now-we’ll-create-the-container-components" class="headerlink" title="Now we’ll create the container components"></a>Now we’ll create the container components</h3><p>This is where things start to get interesting.</p><p>The <code>FormContainer</code> component is just a regular component where the business logic of the form is defined. This is the job of a container component. It uses a regular <code>useDispatch</code> to dispatch actions to the ‘global’ store, and it uses some <em><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-custom.html">custom hooks</a></em> that we’ll define later.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useCallback, useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><br><span class="hljs-keyword">import</span> &#123; Provider, useDispatch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span><br><br><span class="hljs-keyword">import</span> FormContext <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./context&quot;</span><br><span class="hljs-keyword">import</span> &#123; SOME_GLOBAL_FORM_ACTION &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./globalStore&quot;</span><br><span class="hljs-keyword">import</span> &#123; createFormStore, useFormActions, useFormSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./hooks&quot;</span><br><span class="hljs-keyword">import</span> &#123; valuesSelector, requiredFieldsFilledSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./selectors&quot;</span><br><br><span class="hljs-keyword">import</span> Form <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Form&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Form container component.</span><br><span class="hljs-comment"> * In this component we will handle business logic.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;React.FC&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> FormContainer = <span class="hljs-function">(<span class="hljs-params">&#123; formId, children, ...props &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * We&#x27;re free to use the &#x27;global&#x27; dispatch function next to</span><br><span class="hljs-comment">   * the form dispatch function by using useDispatch and useFormDispatch.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> dispatch = useDispatch()<br><br>  <span class="hljs-keyword">const</span> &#123; setFormId &#125; = useFormActions()<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Get values from the form store using our</span><br><span class="hljs-comment">   * custom redux hook &#x27;useFormSelector&#x27;.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> values = useFormSelector(valuesSelector)<br>  <span class="hljs-keyword">const</span> requiredFieldsFilled = useFormSelector(requiredFieldsFilledSelector)<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    setFormId(formId)<br>  &#125;, [setFormId, formId])<br><br>  <span class="hljs-keyword">const</span> onSubmitHandler = useCallback(<br>    (e) =&gt; &#123;<br>      e.preventDefault()<br><br>      <span class="hljs-keyword">if</span> (requiredFieldsFilled) &#123;<br>        dispatch(&#123;<br>          type: SOME_GLOBAL_FORM_ACTION,<br>          payload: &#123; formId, values &#125;,<br>        &#125;)<br>      &#125;<br>    &#125;,<br>    [dispatch, requiredFieldsFilled, formId, values],<br>  )<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;Form onSubmit=&#123;onSubmitHandler&#125; &#123;...props&#125;&gt;<br>      &#123;children&#125;<br>    &lt;/Form&gt;<br>  )<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Connected form container component.</span><br><span class="hljs-comment"> * Connects the component to the form redux store using a custom context.</span><br><span class="hljs-comment"> * This allow the use of custom redux hooks.</span><br><span class="hljs-comment"> * https://react-redux.js.org/next/api/hooks#custom-context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> ConnectedFormContainer = connect(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, &#123;<br>  context: FormContext,<br>&#125;)(FormContainer)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Form container provider.</span><br><span class="hljs-comment"> * Provides a redux store for each form instance and renders the connected form container.</span><br><span class="hljs-comment"> * https://react-redux.js.org/using-react-redux/accessing-store#providing-custom-context</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * You can provide an optional parameter &#x27;store&#x27; which can be useful when writing tests.</span><br><span class="hljs-comment"> * (not covered in this blog post)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;React.FC&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> FormContainerProvider = <span class="hljs-function">(<span class="hljs-params">&#123; store, children, ...props &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Create a new store for every instance of FormContainerProvider.</span><br><span class="hljs-comment">   * &#x27;useMemo&#x27; makes sure we create the store only once before the component will mount.</span><br><span class="hljs-comment">   * &#x27;useRef&#x27; makes sure we get a consistent reference to the store object.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> formStore = useMemo(<span class="hljs-function">() =&gt;</span> store || createFormStore(), [])<br>  <span class="hljs-keyword">const</span> &#123; current &#125; = useRef(formStore)<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;Provider context=&#123;FormContext&#125; store=&#123;current&#125;&gt;<br>      &lt;ConnectedFormContainer &#123;...props&#125;&gt;&#123;children&#125;&lt;/ConnectedFormContainer&gt;<br>    &lt;/Provider&gt;<br>  )<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Export the form container provider instead of the form container component.</span><br><span class="hljs-comment"> * I&#x27;m renaming the wrapper back to FormContainer in the export, but that&#x27;s optional.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> &#123; FormContainerProvider <span class="hljs-keyword">as</span> FormContainer &#125;<br></code></pre></td></tr></table></figure><ul><li>Use the <code>connect</code> HOC (higher-order component) function to specify which context the <code>FormContainer</code> component needs to connect to.</li><li>Pass the custom context and a Redux store as props to a default Redux <code>Provider</code> and wrap the connected component to create a <code>FormContainerProvider</code> that provides the current store to any child components.</li><li>Cheat a little and export <code>FormContainerProvider</code> as <code>FormContainer</code> to help your IDE with auto-import / autocomplete functionality. This is optional.</li></ul><p>Now a <code>FormInput</code> component can reliably retrieve values from the store of the form it’s currently rendered in, even though the component itself is used across different forms. 🤯</p><p>I wasn’t aware that you could pass in an options object as the fourth argument to the <code>connect</code> function! We can simply use <code>null</code> for the first three arguments because we don’t need to use <code>mapStateToProps</code>, <code>mapDispatchToProps</code> or <code>mergeProps</code>. We want to get values using Redux selector hooks instead of mapping state variables to component props. This was common practice when we were working with class-based components, but nowadays we’d like to work with functions (hooks) only.</p><p>Now when we render three different instances of <code>FormContainer</code> for example, <strong>three</strong> Redux stores are created, each with the same initial state but unique internal state over time.</p><p>In theory you could pass some initial state as props to the <code>FormContainer</code> component, which you would pass into the <code>createFormStore</code> function if you want to set up the store with initial values based on props.</p><h3 id="Retrieving-form-values-and-firing-actions-from-a-deeply-nested-component"><a href="#Retrieving-form-values-and-firing-actions-from-a-deeply-nested-component" class="headerlink" title="Retrieving form values and firing actions from a deeply nested component"></a>Retrieving form values and firing actions from a deeply nested component</h3><p>It doesn’t matter how deep this component is nested inside the <code>FormContainer</code>.<br>Calling <code>setValue</code> will update a value in the current form store only, as described above.<br>No more hassle with <code>mapStateToProps</code> or <code>mapDispatchToProps</code>! 😁</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><br><br><span class="hljs-keyword">import</span> &#123; useFormActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./hooks&quot;</span><br><br><span class="hljs-keyword">import</span> FormInput <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./FormInput&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Form input container component.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;React.FC&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> FormInputContainer = <span class="hljs-function">(<span class="hljs-params">&#123; name, children, ...props &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * ❌ creates a subscription and triggers a re-render on all updates to FormContext.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// const &#123; someValue &#125; = useContext(FormContext);</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * ⚠️ creates a subscription to a single store value.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// const someValue = useFormSelector(state =&gt; state.someValue);</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * ✅ creates a memoized subscription to a single store value.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// const someValue = useFormSelector(someValueSelector);</span><br><br>  <span class="hljs-keyword">const</span> &#123; setValue &#125; = useFormActions()<br><br>  <span class="hljs-keyword">const</span> onChangeHandler = useCallback(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> setValue(name, e.target.value), [<br>    setValue,<br>    name,<br>  ])<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;FormInput onChange=&#123;onChangeHandler&#125; &#123;...props&#125;&gt;<br>      &#123;children&#125;<br>    &lt;/FormInput&gt;<br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> FormInputContainer<br></code></pre></td></tr></table></figure><h3 id="Setting-up-some-example-complex-logic-for-our-form"><a href="#Setting-up-some-example-complex-logic-for-our-form" class="headerlink" title="Setting up some example complex logic for our form"></a>Setting up some example complex logic for our form</h3><p>We would need to validate input, write things to localStorage - but not when it’s a password - etc.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Just a single example of all the utility functions</span><br><span class="hljs-comment"> * that we would use in our complex form.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>value An input value</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;object&#125;</span> </span>validationRule A dynamic validation rule</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;boolean&#125;</span> <span class="hljs-variable">isValid</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> validateInput = <span class="hljs-function">(<span class="hljs-params">value, validationRule</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> ((value === <span class="hljs-literal">undefined</span> || value === <span class="hljs-string">&quot;&quot;</span>) &amp;&amp; validationRule?.isRequired) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (value &amp;&amp; value?.length &gt; validationRule?.maxLength) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="And-this-is-where-the-magic-happens"><a href="#And-this-is-where-the-magic-happens" class="headerlink" title="And this is where the magic happens"></a>And this is where the magic happens</h3><p><strong>Hooks.</strong></p><p>React Redux exposes three useful functions which we can use to create custom redux hooks.</p><ul><li><code>createStoreHook</code></li><li><code>createDispatchHook</code></li><li><code>createSelectorHook</code></li></ul><p>If we pass a context into these functions, we can create custom <code>useDispatch</code> and <code>useSelector</code> functions, that only operate on the ‘local’ / ‘sub’ store, the form store in our case.</p><p>In this post I’m creating <code>useFormSelector</code> for example, but if you’re creating complex modals you could create <code>useModalDispatch</code> and <code>useModalSelector</code> for example - and use them if you have a context + store set up as shown above in <code>FormContainer.jsx</code>.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;<br>  createStoreHook,<br>  createDispatchHook,<br>  createSelectorHook,<br>  useDispatch,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><br><span class="hljs-keyword">import</span> FormContext <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./context&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; SOME_GLOBAL_RESET_FORM_ACTION &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../globalStore&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; formIdSelector, validationRulesSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./selectors&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; validateInput &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Form reducer constants.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> SET_FORM_ID = <span class="hljs-string">&quot;SET_FORM_ID&quot;</span>;<br><span class="hljs-keyword">const</span> SET_VALUE = <span class="hljs-string">&quot;SET_VALUE&quot;</span>;<br><span class="hljs-keyword">const</span> SET_VALIDATION_RULES = <span class="hljs-string">&quot;SET_VALIDATION_RULES&quot;</span>;<br><span class="hljs-keyword">const</span> RESET_FORM_STATE = <span class="hljs-string">&quot;RESET_FORM_STATE&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Form reducer initial state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  formId: <span class="hljs-literal">undefined</span>,<br>  values: &#123;&#125;,<br>  validityValues: &#123;&#125;,<br>  validationRules: &#123;&#125;,<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Another standard reducer function.</span><br><span class="hljs-comment"> * This reducer will only handle form actions.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">state</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">action</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">nextState</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, &#123; type, payload &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> SET_FORM_ID:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">formId</span>: payload &#125;;<br>    <span class="hljs-keyword">case</span> SET_VALUE:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        values: &#123;<br>          ...state.values,<br>          [payload.key]: payload.value,<br>        &#125;,<br>        validityValues: &#123;<br>          ...state.validityValues,<br>          [payload.key]: payload.isValid,<br>        &#125;<br>      &#125;;<br>    <span class="hljs-keyword">case</span> SET_VALIDATION_RULES:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        validationRules: &#123; ...state.validationRules, ...payload &#125;,<br>      &#125;;<br>    <span class="hljs-keyword">case</span> RESET_FORM_STATE:<br>      <span class="hljs-keyword">return</span> initialState;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Redux form store factory function.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note that &#x27;preloadedState&#x27; is not used in this example.</span><br><span class="hljs-comment"> * It&#x27;s useful when you want to provide a custom initial state</span><br><span class="hljs-comment"> * when writing tests for example.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;object&#125;</span> </span>preloadedState Optional, default: undefined</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">store</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createFormStore = <span class="hljs-function">(<span class="hljs-params">preloadedState</span>) =&gt;</span><br>  createStore(reducer, preloadedState);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rarely used hook for retrieving the form store directly.</span><br><span class="hljs-comment"> * Preferably, use useFormSelector to access store values.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useFormStore = createStoreHook(FormContext);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Form dispatch hook, similar to react-redux&#x27;s useDispatch hook.</span><br><span class="hljs-comment"> * Actions dispatched using this hook will only affect the specified context.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useFormDispatch = createDispatchHook(FormContext);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Form selector hook, similar to react-redux&#x27;s useSelector.</span><br><span class="hljs-comment"> * Use this hook to retrieve data from the form store.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useFormSelector = createSelectorHook(FormContext);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Hook for convenient access to the form redux actions.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">formActions</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useFormActions = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Use useDispatch and useFormDispatch to be able to</span><br><span class="hljs-comment">   * dispatch actions to both the form store and the global store.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> dispatch = useDispatch();<br>  <span class="hljs-keyword">const</span> formDispatch = useFormDispatch();<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Get (aka select) some values from the form store with &#x27;useFormSelector&#x27;.</span><br><span class="hljs-comment">   * It&#x27;s no problem to use these hooks inside other hooks like this.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> formId = useFormSelector(formIdSelector);<br>  <span class="hljs-keyword">const</span> validationRules = useFormSelector(validationRulesSelector);<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Sets the form id.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">id</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> setFormId = useCallback(<br>    (id) =&gt; formDispatch(&#123; <span class="hljs-attr">type</span>: SET_FORM_ID, <span class="hljs-attr">payload</span>: id &#125;),<br>    [formDispatch],<br>  );<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Sets a form value and does a validation check.</span><br><span class="hljs-comment">   * We keep track of the value&#x27;s validity using the &#x27;validityValues&#x27; object.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">key</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">value</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> setValue = useCallback(<br>    (key, value) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-keyword">const</span> isValid = validateInput(value, validationRules?.[key])<br><br>      formDispatch(&#123;<br>        type: SET_VALUE,<br>        payload: &#123; key, value, isValid &#125;,<br>      &#125;)<br>    &#125;<br>    [formDispatch, validateInput, validationRules],<br>  );<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Sets the validation rules.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">validationRules</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> setValidationRules = useCallback(<br>    (validationRules) =&gt;<br>      formDispatch(&#123; <span class="hljs-attr">type</span>: SET_VALIDATION_RULES, <span class="hljs-attr">payload</span>: validationRules &#125;),<br>    [formDispatch],<br>  );<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Reset the entire form state in the current context.</span><br><span class="hljs-comment">   * And - as an example - also update the global redux store.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> resetFormValues = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    formDispatch(&#123; <span class="hljs-attr">type</span>: RESET_FORM_STATE &#125;);<br>    dispatch(&#123; <span class="hljs-attr">type</span>: SOME_GLOBAL_RESET_FORM_ACTION, <span class="hljs-attr">payload</span>: formId &#125;);<br>  &#125;, [formDispatch, dispatch, formId]);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    setFormId,<br>    setValue,<br>    setValidationRules,<br>    resetFormValues,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="The-icing-on-the-cake-🍰-reselect"><a href="#The-icing-on-the-cake-🍰-reselect" class="headerlink" title="The icing on the cake 🍰 reselect"></a>The icing on the cake 🍰 <a target="_blank" rel="noopener" href="https://github.com/redux/reselect">reselect</a></h3><p>Organize and create your store value selectors in a central location to be re-used across multiple components. A great advantage of writing selectors like this with <code>reselect</code> is that each selector is a ‘pure’ function. You’ll only be dealing with immutable values and a predictable state, which is awesome insurance against ‘side-effects’.</p><p>This is a nice example of solving real-world problems using functional programming in JavaScript (and one of the reasons I like React and Redux in general). We can derive any new value from existing store values by composing selector functions.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> isEqual <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-fast-compare&quot;</span><br><span class="hljs-keyword">import</span> &#123; createSelector, createSelectorCreator, defaultMemoize &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;reselect&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a custom selector creator function.</span><br><span class="hljs-comment"> * The resulting selector performs a deep equality comparison.</span><br><span class="hljs-comment"> * Uses the &#x27;isEqual&#x27; function from &#x27;react-fast-compare&#x27;</span><br><span class="hljs-comment"> * Useful for memoization of values of type object or array.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The default &#x27;createSelector&#x27; performs strict reference equality comparison (with &#x27;===&#x27;).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createDeepEqualSelector = createSelectorCreator(<br>  defaultMemoize,<br>  isEqual,<br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Composable memoized redux selector functions.</span><br><span class="hljs-comment"> * Syntax: createSelector|createDeepEqualSelector(...inputSelectors, resultFn)</span><br><span class="hljs-comment"> * https://github.com/reduxjs/reselect</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Each selector must be a &#x27;pure&#x27; function.</span><br><span class="hljs-comment"> * A benefit of this is that it makes selectors very reliable and easily testable.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> formIdSelector = createSelector(<br>  (state) =&gt; state?.formId,<br>  (formId) =&gt; formId,<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> valuesSelector = createDeepEqualSelector(<br>  (state) =&gt; state?.values || &#123;&#125;,<br>  (values) =&gt; values,<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> validationRulesSelector = createDeepEqualSelector(<br>  (state) =&gt; state?.validationRules || &#123;&#125;,<br>  (validationRules) =&gt; validationRules,<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> validityValuesSelector = createDeepEqualSelector(<br>  (state) =&gt; state?.validityValues || &#123;&#125;,<br>  (validityValues) =&gt; validityValues,<br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Before, we would calculate a value like this inside (multiple) components.</span><br><span class="hljs-comment"> * In this new approach we can move the computation to a re-usable selector, like this:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> requiredFieldsFilledSelector = createSelector(<br>  valuesSelector,<br>  validationRulesSelector,<br>  validityValuesSelector,<br>  (values, validationRules, validityValues) =&gt;<br>    <span class="hljs-built_in">Object</span>.keys(values)<br>      .filter(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> validationRules?.[key]?.required)<br>      .every(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> validityValues?.[key] === <span class="hljs-literal">true</span>),<br>)<br></code></pre></td></tr></table></figure><h3 id="Combining-selectors-and-using-props-or-arguments"><a href="#Combining-selectors-and-using-props-or-arguments" class="headerlink" title="Combining selectors and using props or arguments"></a>Combining selectors and using props or arguments</h3><blockquote><p><a target="_blank" rel="noopener" href="https://react-redux.js.org/next/api/hooks#using-memoizing-selectors">https://react-redux.js.org/next/api/hooks#using-memoizing-selectors</a></p></blockquote><p>You can imagine that a form store contains many properties, some of which you want to combine to create new - more specific - values. Some components don’t need a subscription to the entire <code>formConfigs</code> object in the following example snippet. It could be a large object that some components actually do need to subscribe to, but others might only need a subset of the data from that object. Generally it’s a good idea to move as much logic to selectors when combining values from the store.</p><p>Writing lots of selectors might seem stupid at first, but when selecting a value like <code>state.cart.cart.consumer.billingAddress.street</code> in a few components, there’s a high chance to make a small mistake and write <code>state.cart.consumer.billingAddress.street</code> instead. This is a bug I actually ran into while refactoring, it had gone unnoticed for almost 6 months.</p><p>Defining and having things in a centralised place prevents accidental typo’s and gives the benefit of being able to make a single change to update all affected components.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> formConfigsSelector = createDeepEqualSelector(<br>  (state) =&gt; state?.formConfigs || &#123;&#125;,<br>  (formConfigs) =&gt; formConfigs,<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useShippingAsBillingSelector = createSelector(<br>  (state) =&gt; state?.useShippingAsBilling,<br>  (useShippingAsBilling) =&gt; useShippingAsBilling,<br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Example of an polymorphic selector creator.</span><br><span class="hljs-comment"> * (selector which you can pass an argument)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createFormConfigSelector = <span class="hljs-function">(<span class="hljs-params">formId</span>) =&gt;</span><br>  createDeepEqualSelector(<br>    formConfigsSelector,<br>    (formConfigs) =&gt; formConfigs?.[formId] || &#123;&#125;,<br>  )<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Example usage of an polymorphic selector.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> formConfigShippingSelector = createDeepEqualSelector(<br>  createFormConfigSelector(<span class="hljs-string">&quot;homeShippingForm&quot;</span>),<br>  (formConfigShipping) =&gt; formConfigShipping,<br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This selector selects a value that has slightly different behavior</span><br><span class="hljs-comment"> * as is often the case in more complex apps.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> formConfigBillingSelector = createDeepEqualSelector(<br>  createFormConfigSelector(<span class="hljs-string">&quot;homeBillingForm&quot;</span>),<br>  useShippingAsBillingSelector,<br>  (formConfigBilling, useShippingAsBilling) =&gt;<br>    useShippingAsBilling ? &#123;&#125; : formConfigBilling,<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> combinedFormConfigSelector = createDeepEqualSelector(<br>  formConfigShippingSelector,<br>  formConfigBillingSelector,<br>  (formConfigShipping, formConfigBilling) =&gt; (&#123;<br>    ...formConfigShipping,<br>    ...formConfigBilling,<br>  &#125;),<br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Or:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> combinedFormConfigSelector = createDeepEqualSelector(<br>  formConfigShippingSelector,<br>  formConfigBillingSelector,<br>  (...args) =&gt; <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, ...args),<br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Transforming the selection even further:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> combinedFormConfigValuesSelector = createDeepEqualSelector(<br>  combinedFormConfigSelector,<br>  <span class="hljs-built_in">Object</span>.values,<br>)<br></code></pre></td></tr></table></figure><h3 id="Going-even-further-with-re-reselect-💫"><a href="#Going-even-further-with-re-reselect-💫" class="headerlink" title="Going even further with re-reselect 💫"></a>Going even further with <a target="_blank" rel="noopener" href="https://github.com/toomuchdesign/re-reselect">re-reselect</a> 💫</h3><p>Feel free to skip this part, these examples show more advanced usage of selectors. You probably don’t need this unless you’re dealing with a large, complex and performance intensive app.</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createCachedSelector, LruObjectCache &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;re-reselect&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This creates a selector that caches based on the &#x27;prefix&#x27; value.</span><br><span class="hljs-comment"> * So whenever this selector is called with a previously used prefix it will return the</span><br><span class="hljs-comment"> * previously computed selection, instead of re-evaluating the example &#x27;formatValues&#x27; function.</span><br><span class="hljs-comment"> * The function determining which value the selector should cache on is referred to as &#x27;keySelector&#x27;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note that these variable names from the store are totally random and</span><br><span class="hljs-comment"> * have nothing to do with the examples listed above.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> formattedFormValuesSelector = createCachedSelector(<br>  (state) =&gt; state.values,<br>  (state, format) =&gt; format,<br>  (state, format, prefix) =&gt; prefix,<br>  (values, format, prefix) =&gt; formatValues(values, format, prefix),<br>)(<span class="hljs-function">(<span class="hljs-params">state, format, prefix</span>) =&gt;</span> prefix) <span class="hljs-comment">// Cache selectors by prefix</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This is exactly the same.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> formattedFormValuesSelector = createCachedSelector(<br>  (state) =&gt; state.values, <span class="hljs-comment">// a</span><br>  (state, format) =&gt; format, <span class="hljs-comment">// b</span><br>  (state, format, prefix) =&gt; prefix, <span class="hljs-comment">// c</span><br>  (a, b, c) =&gt; formatValues(a, b, c), <span class="hljs-comment">// resultFn</span><br>)(<span class="hljs-function">(<span class="hljs-params">state, format, prefix</span>) =&gt;</span> prefix) <span class="hljs-comment">// keySelector</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Or:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> formattedFormValuesSelector = createCachedSelector(<br>  (state) =&gt; state.values,<br>  (state, format) =&gt; format,<br>  (state, format, prefix) =&gt; prefix,<br>  formatValues, <span class="hljs-comment">// It&#x27;s just functional programming!</span><br>)(<span class="hljs-function">(<span class="hljs-params">state, format, prefix</span>) =&gt;</span> prefix) <span class="hljs-comment">// Cache selectors by prefix</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Customizing the caching implementation by specifying a custom cache object</span><br><span class="hljs-comment"> * https://github.com/toomuchdesign/re-reselect/tree/master/src/cache#readme</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> formattedFormValuesSelector = createCachedSelector(<br>  (state) =&gt; state.values,<br>  (state, format) =&gt; format,<br>  (state, format, prefix) =&gt; prefix,<br>  formatValues,<br>)(&#123;<br>  keySelector: <span class="hljs-function">(<span class="hljs-params">state, format, prefix</span>) =&gt;</span> prefix, <span class="hljs-comment">// Cache selectors by prefix</span><br>  cacheObject: <span class="hljs-keyword">new</span> LruObjectCache(&#123; <span class="hljs-attr">cacheSize</span>: <span class="hljs-number">5</span> &#125;), <span class="hljs-comment">// Use the &#x27;LruObjectCache&#x27; to cache a maximum of 5 objects</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>I hope these tricks can benefit you in your projects as much as it did in our case!</p><p>If you found this interesting, consider following me on <a target="_blank" rel="noopener" href="https://github.com/woudsma">Github</a>. I’m very much open to questions/feedback, don’t hesitate to send a message or leave a reply. 🙂</p><p>A <a target="_blank" rel="noopener" href="http://passionatepeople.io/">Passionate People</a> collegue of mine - The Spider 🕷 - made a video on how to tackle the problem of component re-renders <strong>without</strong> Redux using the <em>event pattern</em>. Might be worth a watch if you don’t want to / can not use Redux in your app! <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=xMvJyfNY_Q0">Youtube link</a>.</p><hr><h2 id="Links-and-references"><a href="#Links-and-references" class="headerlink" title="Links and references"></a>Links and references</h2><ol><li>Redux’s <a target="_blank" rel="noopener" href="https://github.com/reduxjs/reselect">reselect</a> library</li><li>Create cached selectors with <a target="_blank" rel="noopener" href="https://github.com/toomuchdesign/re-reselect">re-reselect</a></li></ol></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><hr><h3>Comments:</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div></div></article><hr><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href="https://github.com/woudsma" target="_blank"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href="mailto:info@tjerkwoudsma.com" target="_blank"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">&copy; 2021 Tjerk Woudsma<br></p></div></div></div></footer><script src="//code.jquery.com/jquery-2.1.4.min.js"></script><script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" charset="utf-8"></script><script>var disqus_shortname="woudsma";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script>var _paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){var e="//matomo.swarmlet.dev/";_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","6"]);var a=(t=document).createElement("script"),t=t.getElementsByTagName("script")[0];a.type="text/javascript",a.async=!0,a.defer=!0,a.src=e+"matomo.js",t.parentNode.insertBefore(a,t)}()</script><noscript><p><img src="//matomo.swarmlet.dev/matomo.php?idsite=6&amp;rec=1" style="border:0" alt=""></p></noscript></body></html>